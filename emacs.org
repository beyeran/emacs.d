# -*- Mode: Org-Mode; -*-
#
# emacs.org --- André Beyer <beyeran@gmail.com>
# Time-stamp: <2013-03-28 15:04:57 beyeran>
#
#+STARTUP: indent
#+STARTUP: hidestars

* Essentials
** Macros
#+begin_src emacs-lisp :tangle emacs.el
;;
;; file: emacs.el
;;

(defmacro sys-diversification (gnu/linux &optional darwin win)
  "System diversification for Linux, Mac and Windows, focus on Linux"
  `(cond ((sys-type 'darwin) ,darwin)
         ((sys-type 'gnu/linux) ,gnu/linux)
         ((sys-type 'windows-nt) ,win)
         (t nil)))

(defun sys-type (name)
  (if (eq system-type name)
      t
    nil))

(defmacro multiple-global-set-key (key-pairs)
  "Setting multiple global key at once, e.g.:
       (multiple-key-set ((\"\\C-cx\" first-global)
	                      (\"\\M-ax\" second-global)))"
  `(progn
	 ,@(loop for item in key-pairs
			 collect `(global-set-key ,(first item)
									  ',(second item)))))

(defmacro require-beyeran (name)
  "Macro for loading special beyeran extensions"
  (let ((require-symbol (intern (concat "beyeran-" name))))
    `(require ',require-symbol)))

(defmacro multiple-add-to-hook (hook forms)
  "Setting multiple variables/functions to a mode-hook, e.g.:
       (multiple-add-to-hook haskell-mode-hook ('turn-on-haskell-doc
                                                'turn-on-haskell-mode))"
  `(progn
     ,@(loop for item in forms
             collect `(add-hook ',hook ,item))))

(defun flatten (x)
  (cond ((null x) nil)
        ((listp x) (append (flatten (car x))
                           (flatten (cdr x))))
        (t (list x))))
#+end_src
** Init File
#+begin_src emacs-lisp :tangle emacs.el

;; possible differences between paths
(setq explicit-shell-file-name "/bin/zsh"
	  shell-file-name "zsh"

	  dotfiles-dir (file-name-directory
					(or (buffer-file-name) load-file-name))
	  beyeran-dir (concat dotfiles-dir "beyeran/")
	  extensions-dir (concat dotfiles-dir "extensions/")
	  color-theme-dir (concat dotfiles-dir "custom-color-themes/")
	  beyeran-color-theme-dir (concat color-theme-dir "beyeran/"))

(defun add-to-loadpath (name)
  (add-to-list 'load-path (concat extensions-dir name)))

(add-to-list 'load-path dotfiles-dir)
(add-to-list 'load-path beyeran-dir)
(add-to-list 'load-path extensions-dir)

(add-to-list 'custom-theme-load-path beyeran-color-theme-dir)

#+end_src
** Loading Paths
#+begin_src emacs-lisp :tangle emacs.el

(defun load-multiple (folder-list)
  (mapcar #'(lambda (n)
              (add-to-loadpath n)) folder-list))

(setq *extension-list* '("color-theme" 
						   "paredit"
						   "org-mode"
						   "org-mode/lisp"
						   "ido"
                           "rainbow"
						   "ruby-mode"
						   "haskell-mode"
						   "haskell-indent"
						   "clojure-mode"
						   "swank-clojure"
						   "prolog"
						   "scheme"
						   "scss-mode"
						   "smex"
						   "ess"
						   "ess/lisp"
						   "coffee-mode"
						   "shen-mode"
						   "maxima"
                           "stumpwm"
						   "java"))

(sys-diversification
 (append *extension-list* '("/usr/share/emacs/site-lisp/slime/")))

(load-multiple *extension-list*)
#+end_src
** Requirements

#+begin_src emacs-lisp :tangle emacs.el
;; requiring local files

(require-beyeran "misc")
(require-beyeran "auto-insert")
(require-beyeran "paredit")
(require-beyeran "smex")
(require-beyeran "org")
(require-beyeran "org-babel")
(require-beyeran "org-export-templates")
;;(require-beyeran "jekyll")
(require-beyeran "ruby-mode")
(require-beyeran "haskell-mode")
(require-beyeran "clojure-mode")
(require-beyeran "prolog-mode")
;(require-beyeran "shen-mode")
;(require-beyeran "scheme-mode")
;(require-beyeran "scss-mode")
;(require-beyeran "coffee-mode")
;(require-beyeran "ess")
;(require-beyeran "zettel")
(require-beyeran "gtd")
;(require-beyeran "maxima")
;(require-beyeran "java")
(require-beyeran "octave")
;;(require-beyeran "erlang-mode")
(require-beyeran "slime")
(require-beyeran "rainbow")
(require-beyeran "stumpwm")

#+end_src

* General Stuff
** General (font, etc.)
  In here there is some general stuff which means: some settings
  (tool-bar, curser etc).

#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
;;
;; file: beyeran-misc.el
;;

;;;;;;;; general stuff ;;;;;;;
(require 'cl)

(tool-bar-mode 0)
(menu-bar-mode 0)
(scroll-bar-mode 0)
(show-paren-mode 1)
(fringe-mode 0)
(setq-default tab-width 4)

(setq linum-format "%d "
	  global-linum-mode t
	  linum-disabled-modes-list '(eshell-mode wl-summary-mode compilation-mode)
	      inhibit-spalsh-screen nil
		  completion-cycle-threshold 5
		  indent-tabs-mode nil)

    (defun linum-on ()
	  "The overwritten function from linum.el to have some modes disabled"
	  (unless (or (minibufferp) (member major-mode linum-disabled-modes-list)) 
		(linum-mode 1)))

;; Alt as Meta for Mac (german keyboard layout fix)
(defun alt-as-meta-for-mac ()
  (setq mac-command-modifier 'meta
    mac-option-modifier 'none
    default-input-method "MacOSX"))

(sys-diversification
 ()
 (alt-as-meta-for-mac))

#+end_src

** Color Theme
#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
;; color theme

(load-theme 'crshd2 t)
;; (load-theme 'erosion t)

#+end_src

** Cursor
#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
;;;; cursor ;;;;
(setq-default cursor-type 'box)
(setq messages-buffer-max-lines 400
      blink-cursor-delay 0.2
          blink-cursor-interval 0.3)
#+end_src

** Comments and Timestamps
#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
;;;; comments ;;;;
(setf comment-style 'indent)

(add-hook 'emacs-lisp-mode-hook #'imenu-add-menubar-index)
(global-set-key [mouse-3] 'mouse-popup-menubar-stuff)

;;;; time ;;;;
(display-time)
(setf display-time-day-and-date nil)
(setf display-time-24hr-format t)

;;;; timestamp ;;;;
(defvar iso-date-format "%Y-%m-%dT%H:%M:%S:z"
  "Format string for ISO dates.")

(defun iso-timestamp (&optional time)
  (format-time-sting iso-date-format
		     (or time (current-time))))

(defun insert-iso-timestamp ()
  (interactive)
  (insert (iso-timestamp)))

(defun iso-timestamp-sexp (&optional time)
  (parse-time-string (iso-timestamp)))

(require 'time-stamp)
(add-hook 'before-save-hook 'time-stamp)
(setf time-stamp-active t)
#+end_src

** Misc Functions
*** Lorem
   Webdesign is a kind of a hobby for me so I often encounter
   situations where I need to use text columns for veryfing my layout
   settings. The commonly used "lorem ipsum" seems like a standart
   text to do that, here's a function which generates it:

#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
(defun lorem ()
  "Insert a lorem ipsum."
  (interactive)
  (insert "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
          "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
          "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
          "aliquip ex ea commodo consequat. Duis aute irure dolor in "
          "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
          "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
          "culpa qui officia deserunt mollit anim id est laborum."))
#+end_src
*** html umlaute
#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
;;;; Custom Functions ;;;;
(defun html-umlaute ()
  "replaces iso-umlaute with html-umlaute"
  (interactive)
  (let ((case-fold-search nil))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward
              (mapconcat '(lambda (x) (car x)) *html-entities* "\\|")
              nil t)
        (replace-match (cdr (assoc (match-string 0) *html-entities*)))))))

;;;; Variables ;;;;
(setf *html-entities*
  '(("Ä" . "&Auml;")
    ("ä" . "&auml;")
    ("Ö" . "&Ouml;")
    ("ö" . "&ouml;")
    ("Ü" . "&Uuml;")
    ("ü" . "&Uuml;")
    ("ß" . "&szling;")))
#+end_src
*** massive-shrink
#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
(defmacro defshrink (system space)
  `(defun ,system ()
     (interactive)
     (shrink-window ,space)))

(defshrink massive-shrink-darwin 20)
(defshrink massive-shrink-linux 14)
(defshrink massive-shrink-win 25)

(global-set-key (kbd "C-x C-q")
                (sys-diversification
                 'massive-shrink-linux
                 'massive-shrink-darwin))

#+end_src
*** make header (filestamp)
#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
(setq *filestamp-seperator* "-")
(setq *filestamp-seperator-repetition* 46)

(setq *filestamp-user-name* "André Beyer")
(setq *filestamp-user-email* "beyeran at gmail.com")

(defun filestamp-make-seperator (times)
  (if (= 0 times)
      ""
    (concat *filestamp-seperator* (filestamp-make-seperator (- times 1)))))

(setq *filestamp-seperator-builded* (filestamp-make-seperator *filestamp-seperator-repetition*))

(defun filestamp-header-finished (comment-sign)
  (concat comment-sign *filestamp-seperator-builded* "\n"
          comment-sign " file: " "\n"
          comment-sign " " *filestamp-user-name* " <" *filestamp-user-email* ">" "\n"
          comment-sign " Time-stamp: <>" "\n"
          comment-sign *filestamp-seperator-builded* "\n"))

(setq filestamp-auto-insert-alist '((("\\.\\(tex\\|sty\\|cls\\)\\'" . "LaTeX Comment") .
                                     (insert (filestamp-header-finished "%")))
                                    (("\\.\\(lisp\\|lsp\\|cl\\)\\'" . "Lisp Comment") .
                                     (insert (filestamp-header-finished ";;")))
                                    (("\\.\\(hs\\)\\'" . "Haskell Comment") .
                                     (insert (filestamp-header-finished "--")))
                                    (("\\.\\(rb\\|irb\\)\\'" . "Ruby Comment") .
                                     (insert (filestamp-header-finished "##")))
                                    (("\\.\\(sh\\|zsh\\)\\'" . "Shell Comment") .
                                     (insert (filestamp-header-finished "##")))))

(defun filestamp-insert ()
  (interactive)
  (insert (filestamp-header-finished ";;")))

(add-hook 'write-file-hooks 'time-stamp)
(add-hook 'find-file-hooks 'auto-insert)
#+end_src

#+begin_src emacs-lisp :tangle beyeran/beyeran-misc.el
(provide 'beyeran-misc)
#+end_src
** Paredit
#+begin_src emacs-lisp :tangle beyeran/beyeran-paredit.el
;;
;; file: beyeran-paredit.el
;;

;;;;;;;; paredit ;;;;;;;;
(require 'paredit)

(when (require 'paredit "paredit" t)
  (mapc (lambda (hook) (add-hook hook (lambda () (paredit-mode 1))))
        '(emacs-lisp-mode-hook
          lisp-mode-hook
          slime-repl-mode-hook
          slime-mode-hook
          inferior-qi-mode-hook
          qi-mode-hook
          scheme-mode
          clojure-mode-hook)))
#+end_src

#+begin_src emacs-lisp :tangle beyeran/beyeran-paredit.el
(provide 'beyeran-paredit)
#+end_src
** smex
#+begin_src emacs-list :tangle beyeran/beyeran-smex.el
;;
;; file: beyeran-smex.el
;;

(and (require 'ido "ido" t)
     (ido-mode t)
     (require 'smex "smex" t)
     (smex-initialize)
     (setq smex-save-file "~/.smex")
     (smex-auto-update))

(provide 'beyeran-smex)
#+end_src
** rainbow
#+begin_src emacs-lisp :tangle beyeran/beyeran-rainbow.el
(require 'rainbow-mode)

(provide 'beyeran-rainbow)
#+end_src
** stumpwm
#+begin_src emacs-lisp :tangle beyeran/beyeran-stumpwm.el
(require 'stumpwm-mode)

(provide 'beyeran-stumpwm)
#+end_src
** auto-insert
#+begin_src emacs-lisp :tangle beyeran/beyeran-auto-insert.el
;;
;; file: beyeran-auto-insert.el
;;

(require 'autoinsert)

(auto-insert-mode)
(setq auto-insert-query nil
      auto-insert-directory (expand-file-name "~/.emacs.d/auto-complete/"))

(add-hook 'find-file-hooks 'auto-insert)

(setq auto-insert-alist
      '(("\\.lisp$" . ["insert.lisp" auto-update-file])
        ("\\.rb$" . [ "ruby.rb" auto-update-file ])))


(defun insert-today ()
  "Insert today's date into buffer"
  (interactive)
  (insert (format-time-string "%A, %B %e %Y" (current-time))))

(defun auto-update-file ()
  (save-excursion
	;; Replace @@@ with file name
	(while (search-forward "@@@" nil t)
	  (save-restriction
	    (narrow-to-region (match-beginning 0) (match-end 0))
	    (replace-match (file-name-nondirectory buffer-file-name))))))

(define-auto-insert "\.rb" "ruby.rb")

(provide 'beyeran-auto-insert)
#+end_src

* Org-Mode
** generall settings
#+begin_src emacs-lisp :tangle beyeran/beyeran-org.el
;;
;; file: beyeran-org.el
;;

(require 'org)

(add-to-list 'auto-mode-alist '("\\.org$" . org-mode))

(setq org-log-done t
      org-support-shift-select t
          org-src-fontify-natively t
          org-export-with-section-numbers nil)

;; overwriting some org functions
(defun org-cycle-global ()
  (interactive)
  (org-cycle t))

(defun org-cycle-local ()
  (interactive)
  (save-excursion
    (move-beginning-of-line nil)
    (org-cycle)))

(provide 'beyeran-org)

#+end_src
** GTD

General Workflow:
=================

With the combination C-M-r a new buffer opens from where with 't'
or with 'n' new tasks or notes can be captured. The captured Tasks
will be stored in the todo.org file and notes will be stored in the
notes.org file.

All tasks are then gathered under the headline "Task" in the file.
Next step is to schedule these task. This is done by going over the
todo item and then hit C-c C-s. After scheduling the tasks surely
need to be refilled. Refilling means, that items are sorted from
the headline Task, to other headlines (which represent projects). 
This done with C-c C-w.

After scheduling the agenda can be viewed with the "org-agenda"
function. For a short reminder a workflow is sketched in the
following. There, the order is to be thought of chronologically
(1 begins in the morning and 4 ends in the evening).


Workflow:
---------
    1. Take tasks which come to mind
    2. work on already scheduled tasks
    3. review done tasks
    4. refill captured tasks


#+begin_src emacs-lisp :tangle beyeran/beyeran-gtd.el
;;
;; ----[ GTD ]----
;;
;; file: beyeran-gtd.el
;;
;; This is a day planer adaption seen on:
;; http://newartisans.com/2007/08/using-org-mode-as-a-day-planner/
;;

(define-prefix-command 'org-todo-state-map)
	 
(define-key org-mode-map "\C-cx" 'org-todo-state-map)
(define-key org-todo-state-map "x"
  #'(lambda nil (interactive) (org-todo "CANCELLED")))
(define-key org-todo-state-map "d"
  #'(lambda nil (interactive) (org-todo "DONE")))
(define-key org-todo-state-map "f"
  #'(lambda nil (interactive) (org-todo "DEFERRED")))
(define-key org-todo-state-map "w"
  #'(lambda nil (interactive) (org-todo "WAITING")))

(require 'remember)

(add-hook 'remember-mode-hook 'org-remember-apply-template)

(define-key global-map [(control meta ?r)] 'remember)

(sys-diversification
 (custom-set-variables
  '(org-agenda-files (quote ("~/projects/gtd/todo.org")))
  '(org-default-note-file "~/projects/gtd/notes.org" ))
 (custom-set-variables
  '(org-agenda-files (quote ("~/Projects/gtd/todo.org")))
  '(org-default-note-file "~/Projects/gtd/notes.org" )))

(sys-diversification
 (setq org-remember-templates
	   '((116 "* TODO %?\n   %u" "~/projects/gtd/todo.org" "Tasks")
		 (110 "* %u %?" "~/projects/gtd/notes.org" "Notes")))
 (setq org-remember-templates
	   '((116 "* TODO %?\n   %u" "~/Projects/gtd/todo.org" "Tasks")
		 (110 "* %u %?" "~/Projects/gtd/notes.org" "Notes"))))

(custom-set-variables
 '(org-agenda-ndays 7)
 '(org-deadline-warning-days 14)
 '(org-agenda-show-all-dates t)
 '(org-agenda-skip-deadline-if-done t)
 '(org-agenda-skip-scheduled-if-done t)
 '(org-agenda-start-on-weekday nil)
 '(org-reverse-note-order t)
 '(org-fast-tag-selection-single-key (quote expert))

 '(org-agenda-custom-commands
   '(("c" todo "DONE|DEFERRED|CANCELLED" nil)
	 ("w" todo "WAITING" nil)
	 ("W" agenda "" ((org-agenda-ndays 21)))
 	 ("A" agenda ""
	  ((org-agenda-skip-function
		(lambda ()
		  (org-agenda-skip-entry-if 'noteregexp "\\=.*\\[#A\\]")))
	   (org-agenda-ndays 1)
	   (org-agenda-overriding-header "Today's Priority #A tasks: ")))
 	 ("u" alltodo ""
	  ((org-agenda-skip-function
		(lambda ()
		  (org-agenda-skip-entry-if 'scheduled 'deadline 'regexp "\n]+>")))
	   (org-agenda-overriding-header "Unscheduled TODO entries: ")))))

 '(org-remember-store-without-prompt t)
 '(remember-annotation-functions (quote (org-remember-annotation)))

 '(remember-handler-functions (quote (org-remember-handler))))


#+end_src

#+begin_src emacs-lisp :tangle beyeran/beyeran-gtd.el
(provide 'beyeran-gtd)
#+end_src
** Org Babel
#+begin_src emacs-lisp :tangle beyeran/beyeran-org-babel.el
;;
;; file: beyeran-org-babel.el
;;

;;; org babel ;;;
(require 'ob)
(require 'ob-eval)
(require 'ob-lisp)
(require 'ob-ruby)
(require 'ob-R)
(require 'ob-maxima)

(setq org-src-fontify-natevely t
      org-confirm-babel-evaluate nil)

(org-babel-do-load-languages
 'org-babel-load-languages 
 '((emacs-lisp . t)
   (dot . t)
   (lisp . t)
   (octave .t)
   (ditaa . t)
   (R . t)
   (python . t)
   (ruby . t)
   (maxima . t)
   (gnuplot . t)
   (clojure . t)
   (sh . t)))
#+end_src

#+begin_src emacs-lisp :tangle beyeran/beyeran-org-babel.el
(provide 'beyeran-org-babel)
#+end_src

** Org Mode Export Templates
*** Koma
#+begin_src emacs-lisp :tangle beyeran/beyeran-org-export-templates.el
;; #+LaTeX_CLASS: beamer
(unless (boundp 'org-export-latex-classes)
 (setq org-export-latex-classes nil))

(add-to-list 'org-export-latex-classes
             '("koma"
               "\\documentclass[a4paper,12pt]{scrartcl}"
               ("\\section{%s}" . "\\section{%s}")
               ("\\subsection{%s}" . "\\subsection{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection{%s}")
               ("\\paragraph{%s}" . "\\paragraph{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph{%s}")))
#+end_src
*** Beamer
#+begin_src emacs-lisp :tangle beyeran/beyeran-org-export-templates.el
;; Beamer
;; #+LaTeX_CLASS: beamer in org files
(add-to-list 'org-export-latex-classes
             ;; beamer class, for presentations
             '("beamer"
               "\\documentclass[10pt]{beamer}\n
                \\mode<{{{beamermode}}}>\n
      \\usetheme{{{{beamertheme}}}}\n
      \\usecolortheme{{{{beamercolortheme}}}}\n
      \\beamertemplateballitem\n
      \\setbeameroption{show notes}
      \\usepackage[utf8]{inputenc}\n
      \\usepackage{hyperref}\n
      \\usepackage{color}
      \\usepackage{listings}
      \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
  frame=single,
  basicstyle=\\small,
  showspaces=false,showstringspaces=false,
  showtabs=false,
  keywordstyle=\\color{blue}\\bfseries,
  commentstyle=\\color{red},
  }\n
      \\usepackage{verbatim}\n
      \\institute{{{{beamerinstitute}}}}\n          
       \\subject{{{{beamersubject}}}}\n"
               
               ("\\section{%s}" . "\\section*{%s}")
               
               ("\\begin{frame}[fragile]\\frametitle{%s}"
                "\\end{frame}"
                "\\begin{frame}[fragile]\\frametitle{%s}"
                "\\end{frame}")))
#+end_src
#+begin_src emacs-lisp :tangle beyeran/beyeran-org-export-templates.el
(provide 'beyeran-org-export-templates)
#+end_src

** Zettelkasten
#+begin_src emacs-lisp :tangle beyeran/beyeran-zettel.el
;;
;; file: beyeran-zettel.el
;;

#+end_src

Within these section I'm trying to implement something like a electronic 
version of Luhmann's "Zettelkasten". This apparatus is an approach to order
and structure notes. I'm trying to improve my workflow while writing term papers.

The idea is the following: If you read something and see information which you
think you could use later you note them with a reference to the source you read it.
This certain note (I suggest not to cite it but to paraphrase it) should be stored
with keywords fitting to the topic.

Now while writing I make a rough sketch of the content and then search the note file
for the keywords I want to write about. Now I've got all captured notes fitting to
the content I want to write. This method has additionally an advanate in linking
different topics together, depending on my style of tagging notes with keywords.

For example, I've read something about semiotics within a system theoretical
approach. I write a note about it. In my termpapter there should be a chapter on
systems theory, so I search my note file for the keyword "systems theory". There
I find my note to semiotics, as well as note I've read about a while ago on
thermodynamics and entropy. Through this collection I was able to link the semiotic
idea of information with the idea of information within thermodynamic entropy.


The workflow could be generalized like this:
  1. Capture a note
     - paraphrase what you've read
     - add the bibliographic information (bibtex prefered)
     - tagg the note with keywords
  2. Save the note
     The not should be stored at a global spot
  3. Search the note file by a given keyword


The basic usage makes use of org mode capure templates and reftext. At after
invoking a certain key combination at first you are asked on the headline
for the note, than you could choose from a certain reftex file for the
bibliographic information, then you are asked on the page number. After that
you are asked on the keywords (a point which is to be improved, this should be
asked afterwards). After that you are in the buffer which should let you
write and store the note.

#+begin_src emacs-lisp :tangle beyeran/beyeran-zettel.el
;; general variables
(require 'remember)

(org-remember-insinuate)

(defvar *note-file* "notes.org")
(defvar *note-directory* "~/documents/org/")
(defvar *bibliographic-file* "zettel.bib")

(setq org-directory *note-directory*
	  org-default-note-file (concat org-directory *note-file*)
	  org-agenda-include-diary t
	  org-use-fast-todo-selection t)

;; getting bibliographic information
(defun org-mode-reftex-setup ()
  (load-library "reftex")
  (and (buffer-file-name) (file-exists-p (buffer-file-name))
       (progn
		 ;; enable auto-revert-mode to update reftex when bibtex file changes on disk
		 (global-auto-revert-mode t)
		 (reftex-parse-all)
		 ;; add a custom reftex cite format to insert links
		 (reftex-set-cite-format '((?\C-m "\[cite][%l]"))))))

  (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
  (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search)

(defun org-mode-reftex-search ()
  ;;jump to the notes for the paper pointed to at from reftex search
  (interactive)
  (org-open-link-from-string (format "[[%s]]" (reftex-citation t))))

(setq reftex-default-bibliography (list (format "%s%s" 
												*note-directory*
												*bibliographic-file*)))

(setq org-link-abbrev-alist
      '(("bib" . (format "%s%s" *bibliographic-file* "::%s"))))

(setq org-capture-templates '(("z" "Zettel" entry (file org-default-note-file)
							   "* %^{title} \t %^g \n  :CITATION: %(reftex-citation) \n  :PAGE: %^{page}\n\n  %?")))

(add-hook 'org-mode-hook 'org-mode-reftex-setup)

(multiple-global-set-key (("\C-cr" org-capture)))

(provide 'beyeran-zettel)
#+end_src

* Statistics
#+begin_src emacs-lisp :tangle beyeran/beyeran-ess.el
;;
;; file: beyeran-ess.el
;;

(require 'ess-site)

(provide 'beyeran-ess)
#+end_src
* Programming Languages
** Haskell 
#+begin_src emacs-lisp :tangle beyeran/beyeran-haskell-mode.el
(add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))

;;;; Variables ;;;;
(setq haskell-program-name "ghci"
      haskell-font-lock-symbols t
      haskell-hoogle-command "hoogle")

(defun custom-haskell-mode ()
  (haskell-indentation-mode -1)
  (haskell-indent-mode 1)
  (flyspell-prog-mode))

;;;; Hooks and Keys ;;;;
(multiple-add-to-hook haskell-mode-hook ('turn-on-haskell-doc-mode
                                         'turn-on-haskell-font-lock
                                         'turn-on-haskell-decl-scan
                                         'custom-haskell-mode
                                         'turn-on-haskell-simple-indent
                                         (lambda ()
                                           (define-keys haskell-mode-map
                                             '(("RET" newline)
                                               ("TAB" haskell-indent-cycle)
                                               ("C-c =" haskell-indent-insert-equal)
                                               ("C-c |" haskell-indent-insert-guard)
                                               ("C-c o" haskell-indent-insert-otherwise)
                                               ("C-c w" haskell-indent-insert-where)
                                               ("C-c ." haskell-indent-align-guards-and-rhs)
                                               ("C-c i" inferior-haskell-info))))))

(add-hook 'inferior-haskell-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c h") 'haskell-hoogle)
            (turn-on-haskell-doc-mode 1)))


;;;; Requirements ;;;;
(require 'haskell-mode "haskell-mode" t)
(require 'inf-haskell "inf-haskell" t)
;;(require 'haskell-indent "haskell-indent" t)

(provide 'beyeran-haskell-mode)
#+end_src

** Ruby
#+begin_src emacs-lisp :tangle beyeran/beyeran-ruby-mode.el
(autoload 'ruby-mode "ruby-mode"
  "Mode for editing ruby source files" t)

(require 'inf-ruby)

(add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
(add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode))

(autoload 'run-ruby "inf-ruby" "Run an inferior Ruby process")
(autoload 'inf-ruby-keys "inf-ruby"
  "Set local key defs for inf-ruby in ruby-mode")

(add-hook 'ruby-mode-hook
  '(lambda () (inf-ruby-keys)))
#+end_src

#+begin_src emacs-lisp :tangle beyeran/beyeran-ruby-mode.el
(provide 'beyeran-ruby-mode)
#+end_src
** Clojure
#+begin_src emacs-lisp :tangle beyeran/beyeran-clojure-mode.el
(setq clojure-src-root (expand-file-name "~/.emacs.d/extensions"))

(autoload 'clojure-mode "clojure-mode" t)
(autoload 'clojure-test-mode "clojure-test-mode" nil t)

(progn
  (autoload 'swank-clojure-init "swank-clojure")
  (autoload 'swank-clojure-slime-mode-hook "swank-clojure")
  (autoload 'swank-clojure-cmd "swank-clojure")
  (autoload 'swank-clojure-project "swank-clojure"))

;; Java starves programs by default
(setq swank-clojure-extra-vm-args (list "-Xmx1024m"))

(add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))

(provide 'beyeran-clojure-mode)
#+end_src

** Prolog
#+begin_src emacs-lisp :tangle beyeran/beyeran-prolog-mode.el
(autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
(autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)
(autoload 'mercury-mode "prolog" "Major mode for editing Mercury programs." t)

(setq prolog-system 'swi
      auto-mode-alist (append '(("\\.pl$" . prolog-mode)
                                ("\\.m$" . mercury-mode))
                              auto-mode-alist)
          prolog-program-name "/usr/bin/gprolog")

(provide 'beyeran-prolog-mode)
#+end_src
** Shen
#+begin_src emacs-lisp :tangle beyeran/beyeran-shen-mode.el
(require 'shen-mode)
(require 'inf-shen)

(add-to-list 'auto-mode-alist '("\\.shen$" . shen-mode)
                              '("\\.kl$" . shen-mode))

(setq inferior-shen-program "/usr/bin/shen")

(provide 'beyeran-shen-mode)
#+end_src
** Scheme
#+begin_src emacs-lisp :tangle beyeran/beyeran-scheme-mode.el
(require 'quack)
(add-to-list 'auto-mode-alist '("\\.scm$" . scheme-mode))

(setq scheme-program-name "guile")

(add-to-list 'Info-default-directory-list (concat extensions-dir "scheme/info/"))

(add-hook 'scheme-mode-hook
          (lambda ()
            (define-key scheme-mode-map [f1]
              '(lambda ()
                 (interactive)
                 (ignore-errors
                   (let ((symbol (thing-at-point 'symbol)))
                        (info "(r5rs)")
                        (Info-index symbol)))))))

(provide 'beyeran-scheme-mode)
#+end_src
** Python
#+begin_src emacs-lisp :tangle beyeran/beyeran-python-mode.el
(add-to-list 'interpreter-mode-alist '("/usr/bin/python2" . python-mode))

(provide 'beyeran-python-mode)
#+end_src

** Scss
#+begin_src emacs-lisp :tangle beyeran/beyeran-scss-mode.el
(require 'scss-mode)

(sys-diversification
 ()
 (setq scss-sass-command "~/.rvm/gems/ruby-1.9.3-p0/bin/sass"))

(add-to-list 'auto-mode-alist '("\\.scss\\'" . scss-mode))
(add-to-list 'auto-mode-alist '("\\.sass\\'" . scss-mode))

(provide 'beyeran-scss-mode)
#+end_src
** Coffee-Script

#+begin_src emacs-lisp :tangle beyeran/beyeran-coffee-mode.el
(require 'coffee-mode)

(add-to-list 'auto-mode-alist '("\\.coffee$" . coffee-mode))
(add-to-list 'auto-mode-alist '("Cakefile" . coffee-mode))

(defun coffee-custon ()
  "coffee-mode-hook"
  (set (make-local-variable 'tab-width) 2))

(add-hook 'coffee-mode-hook
  '(lambda () (coffee-custom)))

(provide 'beyeran-coffee-mode)
#+end_src
** Erlang
#+begin_src emacs-lisp :tangle beyeran/beyeran-erlang-mode.el
(setq load-path (cons "/usr/lib/erlang/lib/tools-2.6.7/emacs/" load-path)
      erlang-root-dir "/usr/lib/erlang/"
          exec-path (cons "/usr/bin/" exec-path))

(require 'erlang-start)

(provide 'beyeran-erlang-mode)
#+end_src
** Slime
  I've installed quicklisp and in one documentation for it I've found
  this "slime helper" which works quite fine. There will be some
  additions for Scheme and Clojure development.

  ;;;;;;;; slime helper (from quicklisp)
  (load (expand-file-name "~/.config/quicklisp/slime-helper.el"))
  ;; (setq inferior-lisp-program "/Applications/CCL/dx86cl64")
  ;; (setq inferior-lisp-program "/Applications/AllegroCL/alisp")
  (setq inferior-lisp-program "/usr/bin/ccl")

#+begin_src emacs-lisp :tangle beyeran/beyeran-slime.el
(load (expand-file-name "~/.quicklisp/slime-helper.el"))

(require 'slime "slime" t)
(require 'w3m-load)

(setq browse-url-browser-function 'w3m)

;; (defun w3m-browse-url-other-window (url &optional new-window)
;;   (interactive (browse-url-interactive-arg "w3m URL: "))
;;   (let ((pop-up-frames nil))
;; 	(switch-to-buffer-other-window
;; 	 (w3m-get-buffer-create *w3m*))
;; 	(w3m-browse-url url)))
;; 
;; (setq browse-url-browser-function
;;   (list (cons "^ftp:/.*" (lambda (url &optional nf)
;; 						   (call-interactively #'find-file-at-point url)))
;; 		(cons "." #'w3m-browse-url-other-window)))
 (setq slime-enable-evaluate-in-emacs t 
       slime-net-coding-system 'utf-8-unix)

(slime-setup '(slime-fancy slime-asdf slime-references slime-indentation))

(add-hook 'slime-mode-hook
          (lambda ()
            (define-keys slime-mode-map
                '(("C-c s" slime-selector)
                  ("C-j" newline-and-indent)
                  ("TAB" slime-indent-and-complete-symbol)
                  ("C-c C-d c" cltl2-lookup)))))

(add-hook 'slime-repl-mode-hook
          (lambda ()
            (define-keys slime-repl-mode-map
                '(("C-c s" slime-selector)
                  ("C-c C-d c" cltl2-lookup)))))

(defun clojure-slime-config ()
  (require 'slime-autoloads)
  
  (slime-setup '(slime-fancy))

  (setq swank-clojure-classpath
        (list
         (concat clojure-src-root "/clojure/clojure.jar")
         (concat clojure-src-root "/clojure-contrib/target/clojure-contrib-1.2.0-SNAPSHOT.jar")
         (concat clojure-src-root "/swank-clojure/src")
         (concat clojure-src-root "/clojure/test/clojure/test_clojure")))

  (eval-after-load 'slime
    '(progn (require 'swank-clojure)
            (setq slime-lisp-implementations
                  (cons `(clojure ,(swank-clojure-cmd) :init
                                  swank-clojure-init)
                        (remove-if #'(lambda (x) (eq (car x) 'clojure))
                                   slime-lisp-implementations))))))

;; http://groups.google.com/group/clojure/browse_thread/thread/e70ac373b47d7088 
(setq slime-lisp-implementations
	  (sys-diversification 
	   '((sbcl ("/usr/bin/sbcl")) 
		 (ccl ("/usr/bin/ccl")) 
		 (acl ("/usr/bin/alisp")))
	   '(ccl ("/Applications/CCL/dx86cl"))))

(defun pre-slime-clj (&optional clj-p)
  "Stuff to do before SLIME runs" 
  (unless (eq clj-p nil)
    (clojure-slime-config))
  (slime-setup '(slime-fancy)))

(defun run-clojure () 
  "Starts clojure in Slime" 
  (interactive)
  (pre-slime-clj t)
  (slime 'clojure))

(defun run-lisp () 
  "Starts SBCL in Slime" 
  (interactive)
;;  (pre-slime-clj)
  (sys-diversification
   (slime 'sbcl)
   (slime 'ccl)))

#+end_src

#+begin_src emacs-lisp :tangle beyeran/beyeran-slime.el
(provide 'beyeran-slime)
#+end_src
** Maxima
#+begin_src emacs-lisp :tangle beyeran/beyeran-maxima.el
(autoload 'imaxima "imaxima" "maxima frontend" t)
(autoload 'imath "imath" "interactive math mode" t)

(provide 'beyeran-maxima)
#+end_src
** Java
#+begin_src emacs-lisp :tangle beyeran/beyeran-java.el
(require 'javarun)
(add-hook 'java-mode-hook (lambda () (javarun-mode 1)))
(setq javarun-java-path "/usr/bin")

(provide 'beyeran-java)
#+end_src

** Octave
#+begin_src emacs-lisp :tangle beyeran/beyeran-octave.el
(autoload 'octave-mode "octave-mod" nil t)

(sys-diversification ()
  ()
  (setq inferior-octave-program "/Applications/Octave.app/Contents/Resources/bin/octave"))

(setq auto-mode-alist
      (cons '("\\.m$" . octave-mode) auto-mode-alist))

(add-hook 'octave-mode-hook
          (lambda () 
            (abbrev-mode 1)
            (auto-fill-mode 1)
            (if (eq window-system 'x)
                (font-lock-mode 1))))

(provide 'beyeran-octave)
#+end_src
