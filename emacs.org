#+TITLE: Emacs Config
#+AUTHOR: André Pascal Beyer
#+EMAIL: mail@beyeran.site

* Initializing
  
  I finally gave up: after diverse packages (e.g. epl, el-get) did not do the trick,
  I now use *package*.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'package)

  (add-to-list 'package-archives
               '("melpa-stable" . "https://stable.melpa.org/packages/") t)

  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives '("gnu" . (concat proto "://elpa.gnu.org/packages/"))))

  (package-initialize)

#+END_SRC

Some global configs:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq x-stretch-cursor t
        column-number-mode 1)

  (server-start)

  (set-language-environment "UTF-8")
  (setq-default buffer-file-coding-system 'utf-8-unix)
  (setq-default default-buffer-file-coding-system 'utf-8-unix)
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+END_SRC

* Packages
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'cl)

  (setq required-packages
        '(;; org
          org-plus-contrib
          ;; usability
          undo-tree
          magit
          swiper
          aggressive-indent
          ;; powerline
          rainbow-delimiters
          smartparens
          cask
          use-package
          projectile
          textmate
          multiple-cursors
          git-gutter-fringe+
          parinfer
          telephone-line
          bookmark+
          no-littering
          ;; helm
          helm
          helm-company
          helm-ag
          helm-projectile
          ;; templating
          yasnippet
          elixir-yasnippets
          elm-yasnippets
          ;; programming modes
          elixir-mode
          alchemist
          web-mode
          lua-mode
          php-mode
          ess
          go-mode
          inf-ruby
          flycheck
          clojure-mode
          cider
          flycheck-clojure
          elm-mode
          ;; eyecandy
          ;; highlight-indentation
          ;; indent-guide
          twilight-bright-theme
          soothe-theme
          noctilux-theme
          moe-theme
          mellow-theme
          monokai-theme
          exec-path-from-shell
          org-beautify-theme
          org-bullets))

  (defun packages-installed-p ()
    (loop for p in required-packages
          when (not (package-installed-p p)) do (return nil)
          finally (return t)))

  (unless (packages-installed-p)
    ;; check for new package versions
    (message "%s" "Emacs is now refresing its package database...")
    (package-refresh-contents)
    (message " done.")
    ;; install missing packages
    (dolist (p required-packages)
      (when (not (package-installed-p p))
        (package-install p))))

  (require 'use-package)

  ;;
  ;; helper
  ;;
  (defmacro def-on-system (name type)
    `(defun ,(intern (concatenate 'string "on-" (symbol-name name))) (&rest @body)
       (when (equal system-type ,type)
         (progn @body))))

  (def-on-system win 'windows-nt)
  (def-on-system linux 'gnu/linux)
  (def-on-system mac 'darwin)

  (mapc #'load (directory-files "~/.emacs.d/src/" t "\\.el$"))

  (setq package-enable-at-startup nil)
  (package-initialize)

  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize))
#+END_SRC

* Miscellaneous
#+BEGIN_SRC emacs-lisp :tangle src/misc.el
  (defun scratch ()
    "
     Switches to scratch buffer and creates
     it if it doesn't exist.

     Usage: M-x scratch

     This function is useful to Elisp developers.

     Suggestion:
          Add (defalias 's #'scratch) to the init file.
          You can switch to the scratch buffer with > M-x s
     "
    (interactive)
    (let ((buf (get-buffer-create "*scratch*")))
      (switch-to-buffer buf)
      (lisp-interaction-mode)))

  (defalias 's #'scratch)


  (defun python/scratch ()
    (interactive)
    (let ((buf (get-buffer-create "*python-scratch*")))
      ;; Executes functions that would change the current buffer at
      ;; buffer buf
      (with-current-buffer buf
         ;;; Set the new buffer to scratch mode
        (python-mode)
         ;;; Pop to scratch buffer
        (pop-to-buffer buf))))

  (defun sh/scratch ()
    (interactive)
    (let ((buf (get-buffer-create "*sh-scratch*")))
      ;; Executes functions that would change the current buffer at
      ;; buffer buf
      (with-current-buffer buf
         ;;; Set the new buffer to scratch mode
        (sh-mode)
         ;;; Pop to scratch buffer
        (pop-to-buffer buf))))

  (defun groovy/scratch ()
    (interactive)
    (let ((buf (get-buffer-create "*groovy-scratch*")))
      ;; Executes functions that would change the current buffer at
      ;; buffer buf
      (with-current-buffer buf
         ;;; Set the new buffer to scratch mode
        (groovy-mode)
         ;;; Pop to scratch buffer
        (pop-to-buffer buf))))
#+END_SRC
* Usability
*** Bookmarks
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (require 'bookmark+)

  (define-key global-map [f9] 'bookmark-jump)
  (define-key global-map [f10] 'bookmark-set)

  (setq bookmark-default-file "~/.emacs.d/bookmarks")
  (setq bookmark-save-flag 1)

#+END_SRC

*** Helm and Swipe:
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (require 'helm-config)
  (require 'helm-ag)
  (require 'helm-projectile)

  (define-key helm-command-map (kbd "o") 'helm-occur)
  (define-key helm-command-map (kbd "g") 'helm-do-grep)
  (define-key helm-command-map (kbd "SPC") 'helm-all-mark-rings)
  (define-key helm-map (kbd "M-k") 'helm-next-line)
  (define-key helm-map (kbd "M-i") 'helm-previous-line)
  (define-key helm-map (kbd "M-v") 'yank)
  (define-key helm-find-files-map (kbd "M-k") 'helm-next-line)
  (define-key helm-find-files-map (kbd "M-i") 'helm-previous-line)
  (define-key helm-find-files-map (kbd "M-v") 'yank)
  ;; rebind tab to run persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;; make TAB works in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)

  (define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)

  (setq helm-split-window-in-side-p           t
        helm-buffers-fuzzy-matching           t
        helm-move-to-line-cycle-in-source     t
        helm-ff-search-library-in-sexp        t
        helm-ff-file-name-history-use-recentf t
        helm-ag-fuzzy-match                   t)

  (substitute-key-definition 'find-tag 'helm-etags-select global-map)
  (setq projectile-completion-system 'helm)
  (helm-mode 1)

  (require 'helm-files)
  (setq helm-idle-delay 0.1)
  (setq helm-input-idle-delay 0.1)
  (define-key global-map (kbd "C-x b") 'helm-for-files)
  (define-key global-map (kbd "C-x C-f") 'helm-find-files)

  ;; Turn on helm-projectile key bindings
  (helm-projectile-on)

  ;; Display helm buffers always at the bottom
  ;; Source: http://www.lunaryorn.com/2015/04/29/the-power-of-display-buffer-alist.html
  (add-to-list 'display-buffer-alist
               `(,(rx bos "*helm" (* not-newline) "*" eos)
                 (display-buffer-reuse-window display-buffer-in-side-window)
                 (reusable-frames . visible)
                 (side            . bottom)
                 (window-height   . 0.4)))

  (use-package swiper
    :init
    (global-set-key "\C-s" 'swiper))

  ;; Keys
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-s") 'swiper)
  (global-set-key (kbd "C-c i") 'fill-region)
#+END_SRC

*** Rainbow Delimiters
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (require 'rainbow-delimiters)

  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC
*** Aggressive Indent
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (require 'aggressive-indent)

  (add-hook 'prog-mode-hook 'aggressive-indent-mode)
#+END_SRC

*** Fringe Mode
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  ;; A small minor mode to use a big fringe
  (defvar bzg-big-fringe-mode nil)

  (define-minor-mode bzg-big-fringe-mode
    "Minor mode to hide the mode-line in the current buffer."
    :init-value nil
    :global t
    :variable bzg-big-fringe-mode
    :group 'editing-basics
    (if (not bzg-big-fringe-mode)
        (set-fringe-style nil)
      (set-fringe-mode
       (/ (- (frame-pixel-width)
             (* 100 (frame-char-width)))
          2))))

  ;; Now activate this global minor mode
  (global-set-key (kbd "<f12>") 'bzg-big-fringe-mode)

  ;; show changes from git
  (global-git-gutter+-mode)
#+END_SRC
*** undo-tree
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  ;; undo-tree
  (global-undo-tree-mode)

#+END_SRC

*** Flycheck
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC
*** Projectile
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (projectile-global-mode)

#+END_SRC
*** Company
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (global-company-mode)

#+END_SRC
*** Smartparens
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (use-package smartparens-config
    :ensure smartparens
    :config
    (progn
      (show-smartparens-global-mode t)))

  (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
  (remove-hook 'prog-mode-hook #'smartparens-mode)

  (bind-keys
   :map smartparens-mode-map
   ("C-M-a" . sp-beginning-of-sexp)
   ("C-M-e" . sp-end-of-sexp)
   
   ("C-<down>" . sp-down-sexp)
   ("C-<up>"   . sp-up-sexp)
   ("M-<down>" . sp-backward-down-sexp)
   ("M-<up>"   . sp-backward-up-sexp)
   
   ("C-M-f" . sp-forward-sexp)
   ("C-M-b" . sp-backward-sexp)
   
   ("C-M-n" . sp-next-sexp)
   ("C-M-p" . sp-previous-sexp)
   
   ("C-S-f" . sp-forward-symbol)
   ("C-S-b" . sp-backward-symbol)
   
   ("C-<right>" . sp-forward-slurp-sexp)
   ("M-<right>" . sp-forward-barf-sexp)
   ("C-<left>"  . sp-backward-slurp-sexp)
   ("M-<left>"  . sp-backward-barf-sexp)
   
   ("C-M-t" . sp-transpose-sexp)
   ("C-M-k" . sp-kill-sexp)
   ("C-k"   . sp-kill-hybrid-sexp)
   ("M-k"   . sp-backward-kill-sexp)
   ("C-M-w" . sp-copy-sexp)
   
   ("C-M-d" . delete-sexp)
   
   ("M-<backspace>" . backward-kill-word)
   ("C-<backspace>" . sp-backward-kill-word)
   ([remap sp-backward-kill-word] . backward-kill-word)
   
   ("M-[" . sp-backward-unwrap-sexp)
   ("M-]" . sp-unwrap-sexp)
   
   ("C-x C-t" . sp-transpose-hybrid-sexp)
   
   ("C-c ("  . wrap-with-parens)
   ("C-c ["  . wrap-with-brackets)
   ("C-c {"  . wrap-with-braces)
   ("C-c \"" . wrap-with-double-quotes)
   ("C-c _"  . wrap-with-underscores)
   ("C-c `"  . wrap-with-back-quotes))
#+END_SRC
*** Spell Check
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (on-mac
   (setq ispell-program-name "/usr/local/bin/aspell"))
#+END_SRC

*** Tramp
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (on-win
   (require 'tramp)
   (setq tramp-default-method "pscp")
   (setq tramp-verbose 9))
#+END_SRC
*** Dired
    I put an "x" inside the name so it will be loaded later.

#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (require 'dired)

  (setq dired-listing-switches "-lah")

  (define-key dired-mode-map (kbd "C-l") 'dired-subtree-toggle)
  (define-key dired-mode-map (kbd "C-j") 'dired-subtree-toggle)

  (setq dired-hide-details-mode 1)
#+END_SRC

*** No-Littering
#+BEGIN_SRC emacs-lisp :tangle src/usability.el
  (require 'no-littering)
#+END_SRC

* ORG
** Basics
#+BEGIN_SRC emacs-lisp :tangle src/custom-org.el
  ;; preview fragments via imagemagick
  (setq org-latex-create-formula-image-program 'imagemagick)

  (setq inferior-julia-program-name "julia")
  (setq inferior-ess-julia-program-name "julia")

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
     (R . t)
     (plantuml . t)
     (lisp . t)
     (scheme . t)
     (ruby . t)
     (R . t)
     (clojure . t)
     (python . t)))

  ;; ess
  (use-package ess :init
    (autoload 'R-mode "ess-site.el" "ESS" t)
    (add-to-list 'auto-mode-alist '("\\.R$" . R-mode))
    (add-to-list 'auto-mode-alist '("\\.ji$" . julia-mode)))

  ;; ditaa
  (on-mac
   (setq org-ditaa-jar-path "/usr/local/bin/ditaa"))

  ;; plantuml
  (on-mac
   (setq org-plantuml-jar-path
         (expand-file-name "~/.emacs.d/bin/plantuml.jar")))

  ;; enable selecting
  (setq org-support-shift-select t)

  ;; cider as clojure backend
  (setq org-babel-clojure-backend 'cider)
  (require 'cider)

  ;; blocks
  (setq org-edit-src-content-intendation 0
        org-src-tab-acts-natively t
        org-src-fontify-natively t
        org-confirm-babel-evaluate nil
        org-support-shift-select 'always)
#+END_SRC

** Organize
#+BEGIN_SRC emacs-lisp :tangle src/apb-organize.el
  (setq org-capture-templates
        '(("t" "Todo [inbox]" entry
           (file+headline "~/gtd/inbox.org" "Tasks")
           "* TODO %i%?")))

  (setq org-refile-targets '(("~/gtd/gtd.org" :maxlevel . 3)))
  (setq org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)")))


  (setq org-agenda-files '("~/gtd/"))

  (define-key global-map "\C-cc" 'org-capture)
  (define-key global-map "\C-ca" 'org-agenda)
#+END_SRC

* Programming Modes
** Elixir
#+BEGIN_SRC emacs-lisp :tangle src/apb-elixir.el
  (use-package elixir-mode
    :init
    (add-hook 'elixir-mode-hook 'global-company-mode))

  (use-package alchemist)
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp :tangle src/apb-python.el
  (on-win
   (setq python-shell-interpreter "c:/Python27/python.exe -i"))
#+END_SRC

** Clojure

#+BEGIN_SRC emacs-lisp :tangle src/apb-clojure.el
  ;; configure cider
  (setq nrepl-hide-special-buffers t
        cider-repl-pop-to-buffer-on-connect nil
        cider-popup-stacktraces nil
        cider-repl-popup-stacktraces t)

  ;; useful keybindings when using clojur from org
  ;; (org-defkey org-mode-map (kbd "C-x C-e") 'cider-eval-last-sexp)
  ;; (org-defkey org-mode-map (kbd "C-c C-d") 'cider-doc)


#+END_SRC
** Groovy

#+BEGIN_SRC emacs-lisp  :tangle src/apb-groovy.el
  (add-to-list 'auto-mode-alist '("\.groovy$" . groovy-mode))
  (add-to-list 'auto-mode-alist '("\.gradle$" . groovy-mode))
  (add-to-list 'auto-mode-alist '("\.stark$" . groovy-mode))

  (add-to-list 'interpreter-mode-alist '("groovy" . groovy-mode))
#+END_SRC

** Scala
#+BEGIN_SRC emacs-lisp :tangle src/apb-scala.el
  (use-package ensime
    :ensure t
    :pin melpa-stable)

  (setq exec-path (append exec-path '("c:/Program Files (x86)/sbt/bin/sbt.bat")))

  ;; and again explicit
  (setq
   ensime-sbt-command "c:/Program Files (x86)/sbt/bin/sbt.bat"
   sbt:progam-name "c:/Program Files (x86)/sbt/bin/sbt.bat")

  (require 'ensime)

  (add-hook 'scala-mode-hook 'ensime-scala-mode-hook)
#+END_SRC

** FAS

#+BEGIN_SRC emacs-lisp :tangle src/fas-mode.el
  (defun fas-to-regex-region (start end)
    "Takes a selected FAS (without FieldID and PT), converts it to a regex
  and copies it to clipboard."
    (interactive "r")
    (kill-new
     (replace-regexp-in-string "\\(.*\\)" ".*\\1.*"
                               (replace-regexp-in-string "|<[a-z\_#0-9]+>" "\|<.*>" (buffer-substring start end)))))

  (setq fas-highlights
        '(("^[^\t]+" . font-lock-function-name-face)
          ("\t\\([^\t]+\\)\t" . (1 font-lock-keyword-face))
          ("[^ \t]+\\(<\\([^u]\\|u\\([^n]\\|n[^k]\\)\\)[A-Za-z0-9#_]+>\\)" . (1 font-lock-builtin-face))
          ("\\([^ \t]+\\)<\\([^u]\\|u\\([^n]\\|n[^k]\\)\\)[a-z0-9#_]+>" . (1 font-lock-type-face))
          ("\\([^ \t]+\\)|<unk>" . font-lock-doc-face)
          ("\t" . font-lock-comment-face)))

  (define-derived-mode fas-mode fundamental-mode "fas"
    "major mode for editing fas files."
    (setq font-lock-defaults '(fas-highlights)))

  (add-to-list 'auto-mode-alist '("\.fieldannotatedstring" . fas-mode))

  (provide 'fas-mode)
#+END_SRC

** Unit Test

#+BEGIN_SRC emacs-lisp :tangle src/unit-test-mode.el
  (setq unit-test-mode-syntax-table
        (let ((syn-table (make-syntax-table)))
          (modify-syntax-entry ?\/ ". 12 b" syn-table)
          (modify-syntax-entry ?\n "> b" syn-table)
          (modify-syntax-entry ?\" "(\"" syn-table)
          syn-table))

  (setq unit-test-font-lock
        '(("(\\(:\\(intent\\|descr\\|conv\\) .*\\))" . (2 font-lock-function-name-face)) 
          ("\\(\\(@Test\\|form\\|^in\\) \\|assertPolarity(true)\\)" . font-lock-keyword-face)
          ("id=\\([A-Za-z0-9\$_]+\\)" . (1 font-lock-builtin-face))
          ("$[A-Z0-9_]+" . font-lock-warning-face)
          ("<[a-z0-9_]+>" . font-lock-warning-face)))

  (define-derived-mode unit-test-mode fundamental-mode "unit-test"
    "major mode for editing unit-test files." 
    (setq font-lock-defaults '((unit-test-font-lock))) 
    (set-syntax-table unit-test-mode-syntax-table))

  (add-to-list 'auto-mode-alist '("\.test" . unit-test-mode))

  (provide 'unit-test-mode)
#+END_SRC

** JSGF

#+BEGIN_SRC emacs-lisp :tangle src/jsgf-mode.el
  (defvar jsgf-mode-hook nil)

  (defvar jsgf-keywords
    '("import" "grammar" "JSGF"))

  (defvar jsgf-constants
    '("public"))

  (defvar jsgf-tab-width 2)

  (defvar jsgf-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map "\C-j" 'newline-and-indent)
      map)
    "Keymap for `jsgf-mode'.")

  (setq jsgf-font-lock-defaults
        '(("grammar \\(\\sw+\\)" . (1 font-lock-function-name-face))
          ("\\(<[^>]+>\\)\\s-*=" . (1 font-lock-function-name-face))
          ("\\(<[^>]+>\\){[^}]+}\\s-*=" . (1 font-lock-function-name-face))
          ("\\$\\(\\sw+\\)" . (1 font-lock-variable-name-face))
          ("<[^>]+>" . font-lock-type-face)
          ("\\(\\sw+\\):\\([^,}]\\)" . (1 font-lock-builtin-face))
          ("\\(\\sw+\\):\\([^,}]+\\)" . (2 font-lock-doc-face))
          ("import\\|grammar\\|JSGF" . font-lock-keyword-face)
          ("public" . font-lock-constant-face)))

  (defvar jsgf-mode-syntax-table
    (let ((st (make-syntax-table)))
      (modify-syntax-entry ?_ "w" st)
      (modify-syntax-entry ?/ ". 124b" st)
      (modify-syntax-entry ?* ". 23" st)
      (modify-syntax-entry ?\n "> b" st)
      st)
    "Syntax table for `jsgf-mode'.")

   ;;; Indentation
  (defun jsgf-indent-line ()
    "Indent current line of Jsgf code."
    (interactive)
    (let ((savep (> (current-column) (current-indentation)))
          (indent (condition-case nil (max (jsgf-calculate-indentation) 0)
                    (error 0))))
      (if savep
          (save-excursion (indent-line-to indent))
        (indent-line-to indent))))


  (defun jsgf-get-sexp-indent ()
    (save-excursion
      (condition-case nil
          (progn (goto-char (+ 1 (scan-lists (point) -1 1)))
                 (skip-syntax-forward "-")
                 (current-column))
        (scan-error nil))))

  (defun jsgf-find-ruledef-indent ()
    (save-excursion
      (search-backward-regexp ";\\|=")
      (if (char-equal (char-after) ?=)
          (progn
            (forward-char)
            (skip-syntax-forward "-")
            (message "%d" (point))
            (if (= (point-at-eol) (point)) jsgf-tab-width
              (current-column)))
        nil)))

  (defun jsgf-calculate-indentation ()
    "Return the column to which the current line should be indented."
    (if (bobp)
        nil
      (let ((jsgf-indent-found nil) cur-indent)
        (beginning-of-line)
        (save-excursion
          (or (jsgf-get-sexp-indent)
              (jsgf-find-ruledef-indent)
              nil)))))

  ;;;###autoload
  (add-to-list 'auto-mode-alist '("\\.jsgf\\'" . jsgf-mode))

  ;;;###autoload
  (define-derived-mode jsgf-mode prog-mode "Jsgf"
    "A major mode for editing Jsgf files."
    :syntax-table jsgf-mode-syntax-table
    (setq-local comment-start "// ")
    (setq-local comment-start-skip "\\(//+\\|/\\*+\\)\\s *")
    (setq font-lock-defaults '((jsgf-font-lock-defaults)))
    (setq-local indent-line-function 'jsgf-indent-line))

  (provide 'jsgf-mode)
#+END_SRC

* Looks
** Color Theme

#+BEGIN_SRC emacs-lisp :tangle src/looks.el
  ;; (require 'moe-theme)
  ;; (moe-dark)
  ;; (load-theme 'noctilux)
  ;; (load-theme 'org-beautify-theme)
  (load-theme 'doom-tomorrow-night)

  (global-hl-line-mode 1)
  (set-face-background 'hl-line "#202020")
  (set-face-foreground 'highlight nil)

  (custom-set-faces
   '(mode-line ((t (:box (:line-width 0))))))
#+END_SRC
** Font

#+BEGIN_SRC emacs-lisp :tangle src/looks.el
  (on-mac
   (set-face-attribute 'default nil :font "Monaco-12"))

  (on-linux
   (set-face-attribute 'default nil :font "Monaco-9"))

  (on-win
   (set-face-attribute 'default nil :font "Consolas-10"))

  ;; Fira code
  ;; This works when using emacs --daemon + emacsclient
  (add-hook 'after-make-frame-functions (lambda (frame) (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")))
  ;; This works when using emacs without server/client
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
  ;; I haven't found one statement that makes both of the above situations work, so I use both for now

  (defconst fira-code-font-lock-keywords-alist
    (mapcar (lambda (regex-char-pair)
              `(,(car regex-char-pair)
                (0 (prog1 ()
                     (compose-region (match-beginning 1)
                                     (match-end 1)
                                     ;; The first argument to concat is a string containing a literal tab
                                     ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
            '(("\\(www\\)"                   #Xe100)
              ("[^/]\\(\\*\\*\\)[^/]"        #Xe101)
              ("\\(\\*\\*\\*\\)"             #Xe102)
              ("\\(\\*\\*/\\)"               #Xe103)
              ("\\(\\*>\\)"                  #Xe104)
              ("[^*]\\(\\*/\\)"              #Xe105)
              ("\\(\\\\\\\\\\)"              #Xe106)
              ("\\(\\\\\\\\\\\\\\)"          #Xe107)
              ("\\({-\\)"                    #Xe108)
              ("\\(\\[\\]\\)"                #Xe109)
              ("\\(::\\)"                    #Xe10a)
              ("\\(:::\\)"                   #Xe10b)
              ("[^=]\\(:=\\)"                #Xe10c)
              ("\\(!!\\)"                    #Xe10d)
              ("\\(!=\\)"                    #Xe10e)
              ("\\(!==\\)"                   #Xe10f)
              ("\\(-}\\)"                    #Xe110)
              ("\\(--\\)"                    #Xe111)
              ("\\(---\\)"                   #Xe112)
              ("\\(-->\\)"                   #Xe113)
              ("[^-]\\(->\\)"                #Xe114)
              ("\\(->>\\)"                   #Xe115)
              ("\\(-<\\)"                    #Xe116)
              ("\\(-<<\\)"                   #Xe117)
              ("\\(-~\\)"                    #Xe118)
              ("\\(#{\\)"                    #Xe119)
              ("\\(#\\[\\)"                  #Xe11a)
              ("\\(##\\)"                    #Xe11b)
              ("\\(###\\)"                   #Xe11c)
              ("\\(####\\)"                  #Xe11d)
              ("\\(#(\\)"                    #Xe11e)
              ("\\(#\\?\\)"                  #Xe11f)
              ("\\(#_\\)"                    #Xe120)
              ("\\(#_(\\)"                   #Xe121)
              ("\\(\\.-\\)"                  #Xe122)
              ("\\(\\.=\\)"                  #Xe123)
              ("\\(\\.\\.\\)"                #Xe124)
              ("\\(\\.\\.<\\)"               #Xe125)
              ("\\(\\.\\.\\.\\)"             #Xe126)
              ("\\(\\?=\\)"                  #Xe127)
              ("\\(\\?\\?\\)"                #Xe128)
              ("\\(;;\\)"                    #Xe129)
              ("\\(/\\*\\)"                  #Xe12a)
              ("\\(/\\*\\*\\)"               #Xe12b)
              ("\\(/=\\)"                    #Xe12c)
              ("\\(/==\\)"                   #Xe12d)
              ("\\(/>\\)"                    #Xe12e)
              ("\\(//\\)"                    #Xe12f)
              ("\\(///\\)"                   #Xe130)
              ("\\(&&\\)"                    #Xe131)
              ("\\(||\\)"                    #Xe132)
              ("\\(||=\\)"                   #Xe133)
              ("[^|]\\(|=\\)"                #Xe134)
              ("\\(|>\\)"                    #Xe135)
              ("\\(\\^=\\)"                  #Xe136)
              ("\\(\\$>\\)"                  #Xe137)
              ("\\(\\+\\+\\)"                #Xe138)
              ("\\(\\+\\+\\+\\)"             #Xe139)
              ("\\(\\+>\\)"                  #Xe13a)
              ("\\(=:=\\)"                   #Xe13b)
              ("[^!/]\\(==\\)[^>]"           #Xe13c)
              ("\\(===\\)"                   #Xe13d)
              ("\\(==>\\)"                   #Xe13e)
              ("[^=]\\(=>\\)"                #Xe13f)
              ("\\(=>>\\)"                   #Xe140)
              ("\\(<=\\)"                    #Xe141)
              ("\\(=<<\\)"                   #Xe142)
              ("\\(=/=\\)"                   #Xe143)
              ("\\(>-\\)"                    #Xe144)
              ("\\(>=\\)"                    #Xe145)
              ("\\(>=>\\)"                   #Xe146)
              ("[^-=]\\(>>\\)"               #Xe147)
              ("\\(>>-\\)"                   #Xe148)
              ("\\(>>=\\)"                   #Xe149)
              ("\\(>>>\\)"                   #Xe14a)
              ("\\(<\\*\\)"                  #Xe14b)
              ("\\(<\\*>\\)"                 #Xe14c)
              ("\\(<|\\)"                    #Xe14d)
              ("\\(<|>\\)"                   #Xe14e)
              ("\\(<\\$\\)"                  #Xe14f)
              ("\\(<\\$>\\)"                 #Xe150)
              ("\\(<!--\\)"                  #Xe151)
              ("\\(<-\\)"                    #Xe152)
              ("\\(<--\\)"                   #Xe153)
              ("\\(<->\\)"                   #Xe154)
              ("\\(<\\+\\)"                  #Xe155)
              ("\\(<\\+>\\)"                 #Xe156)
              ("\\(<=\\)"                    #Xe157)
              ("\\(<==\\)"                   #Xe158)
              ("\\(<=>\\)"                   #Xe159)
              ("\\(<=<\\)"                   #Xe15a)
              ("\\(<>\\)"                    #Xe15b)
              ("[^-=]\\(<<\\)"               #Xe15c)
              ("\\(<<-\\)"                   #Xe15d)
              ("\\(<<=\\)"                   #Xe15e)
              ("\\(<<<\\)"                   #Xe15f)
              ("\\(<~\\)"                    #Xe160)
              ("\\(<~~\\)"                   #Xe161)
              ("\\(</\\)"                    #Xe162)
              ("\\(</>\\)"                   #Xe163)
              ("\\(~@\\)"                    #Xe164)
              ("\\(~-\\)"                    #Xe165)
              ("\\(~=\\)"                    #Xe166)
              ("\\(~>\\)"                    #Xe167)
              ("[^<]\\(~~\\)"                #Xe168)
              ("\\(~~>\\)"                   #Xe169)
              ("\\(%%\\)"                    #Xe16a)
             ;; ("\\(x\\)"                   #Xe16b) This ended up being hard to do properly so i'm leaving it out.
              ("[^:=]\\(:\\)[^:=]"           #Xe16c)
              ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
              ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

  (defun add-fira-code-symbol-keywords ()
    (font-lock-add-keywords nil fira-code-font-lock-keywords-alist))

  (add-hook 'prog-mode-hook
            #'add-fira-code-symbol-keywords)

  ;; show tabs with a special symbol
  (let
      ((d (make-display-table)))
    (aset d 9 (vector ? ?| (decode-char 'ucs #Xe135) ? ))
    (set-window-display-table nil d))
#+END_SRC

** UI
#+BEGIN_SRC emacs-lisp :tangle src/looks.el
  ;; encoding
  (prefer-coding-system 'utf-8-emacs-unix)
  (setq set-buffer-file-coding-system 'utf-8-emacs-unix)

  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
  (setq inhibit-startup-echo-area-message t)
  (setq inhibit-startup-message t)

  ;; mighty 80 char rule!
  (setq-default fill-column 80)

  ;; (use-package power-line
  ;;   :init (powerline-default-theme))

  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)

  (use-package org-bullets-mode
    :init (org-bullets-mode))

  ;; indentation
  ;; (indent-guide-global-mode)

  ;; (define-globalized-minor-mode beyeran-global-highlight-mode highlight-indentation-mode
  ;;   (lambda () (highlight-indentation-mode)))

  ;; (beyeran-global-highlight-mode 1)

  (telephone-line-mode t)

  (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
        telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
        telephone-line-primary-right-separator 'telephone-line-cubed-right
        telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)

  (setq telephone-line-height 24
        telephone-line-evil-use-short-tag t)
#+END_SRC
