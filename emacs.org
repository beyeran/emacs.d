#+TITLE:  Emacs Configuration File
#+AUTHOR: André P. Beyer
#+EMAIL:  mail@beyeran.site

* Introduction

  This is my =.emacs= file. It's mostly ripped off from Howard Abrams.

** Loading this File

   To "load" the contents of this file, add the following to =$HOME/.emacs=:

   #+BEGIN_SRC elisp :tangle no
     (load-file "~/.emacs.d/elisp/init-main.el")
   #+END_SRC

* General Settings
  
  Setting up the paths so emacs can find all the relvant
  configurations.

  #+BEGIN_SRC elisp
    (defconst apb/emacs-directory (expand-file-name ".emacs.d" (getenv "HOME")))

    (defconst apb/emacs-elisp-directory (expand-file-name "elisp" apb/emacs-directory))

    (add-to-list 'load-path apb/emacs-elisp-directory)

    (setq x-stretch-cursor t
          column-number-mode 1)

    (set-language-environment "UTF-8")

    (setq-default buffer-file-coding-system 'utf-8-unix)
    (setq-default default-buffer-file-coding-system 'utf-8-unix)
    (set-default-coding-systems 'utf-8-unix)
    (prefer-coding-system 'utf-8-unix)

    (defun apb/emacs-subdiretory (d) (expand-file-name d apb/emacs-directory))
  #+END_SRC

  Loading helper library:

  #+BEGIN_SRC elisp
    (require 'apb-helpers)
  #+END_SRC
	
* Own Definitions

  #+BEGIN_SRC elisp
    (require 'cl)

    (defmacro def-on-system (name type)
      `(defun ,(intern (concatenate 'string "on-" (symbol-name name))) (&rest @body)
	 (when (equal system-type ,type)
	   (progn @body))))

    (def-on-system win 'windows-nt)
    (def-on-system linux 'gnu/linux)
    (def-on-system mac 'darwin)
  #+END_SRC

* Package Initialization
** Package Manager

   #+BEGIN_SRC elisp
     (require 'package)

     (setq package-archives '(("org"      . "http://orgmode.org/elpa/")
			      ("gnu"      . "http://elpa.gnu.org/packages/")
			      ("melpa"    . "http://melpa.org/packages/")
			      ("marmalde" . "http://marmalade-repo.org/packages/")))

     (package-initialize)
     (package-refresh-contents)
   #+END_SRC

** Use-Package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+BEGIN_SRC elisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (require 'use-package)
   #+END_SRC

** Init File Support

   Load up a collection of enhancements to Emacs Lisp, including [[https://github.com/magnars/dash.el][dash]],
   [[https://github.com/magnars/s.el][s]] for string manipulation, and [[https://github.com/rejeep/f.el][f]] for file manipulation.

   #+BEGIN_SRC elisp
     (require 'cl)

     (use-package dash
       :ensure t
       :config (eval-after-load "dash" '(dash-enable-font-lock)))

     (use-package s
       :ensure t)

     (use-package f
       :ensure t)
   #+END_SRC

** Tabs vs. Spaces

   Everybody hate tabs in my sorce code!

   #+BEGIN_SRC elisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 4)
   #+END_SRC

   Make tab key do indent first then comlete.

   #+BEGIN_SRC elisp
     (setq-default tab-always-ident 'complete)
   #+END_SRC

** Misc Variable Settings
   
   Abbreviate yes-or-no:
   #+BEGIN_SRC elisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   Keep the point in center while scolling:
   #+BEGIN_SRC elisp
     (setq scroll-conservatively 10000
           scroll-preserve-screen-position t)
   #+END_SRC

** Display Settings

   #+BEGIN_SRC elisp
     (setq initial-scratch-message "")
     (setq visible-bell t)

     (when (window-system)
       (tool-bar-mode 0)
       (when (fboundp 'horizontal-scroll-bar-mode)
         (horizontal-scroll-bar-mode -1))
       (scroll-bar-mode -1)
       (menu-bar-mode 0))
   #+END_SRC

** Fill Mode

   Automatically wrapping when you get to the end of a line (or the
   fill-region):

   #+BEGIN_SRC elisp
     (use-package fill
       :bind (("C-c T f" . auto-fill-mode)
              ("C-c T f" . toggle-trucate-lines))
       :init (add-hook 'org-mode-hook 'turn-on-auto-fill)
       :diminish auto-fill-mode)
   #+END_SRC

** Undo and Redo

   According to [[http://ergoemacs.org/emacs/emacs_best_redo_mode.html][this article]], I get better functionality than
   the =redo+= plugin (which I can't seem to get working well).

   #+BEGIN_SRC elisp
     (use-package undo-tree
       :ensure t
       :diminish undo-tree-mode
       :init
       (global-undo-tree-mode 1)
       :config
       (defalias 'redo 'undo-tree-redo)
       :bind (("C-z" . undo)     ; Zap to character isn't helpful
              ("C-S-z" . redo)))
   #+END_SRC

** Better Jumping

   Mostly using the [[https://github.com/abo-abo/avy][avy]] project's [[help:avy-goto-word-timer][avy-goto-word-1]] function, so I bind
   that to =C-c j=, but the recent update to include a timer feature,
   seems awful sweet:

   #+BEGIN_SRC elisp
     (use-package avy
       :ensure t
       :init (setq avy-background t))
   #+END_SRC

   Shame that the =:bind= option for =use-package= doesn't actually work.
   Let's do a temporary fix:

   #+BEGIN_SRC elisp
     (global-set-key (kbd "s-h") 'avy-goto-char-timer)
     (global-set-key (kbd "s-j") 'avy-goto-char-timer)
     (global-set-key (kbd "s-H") 'avy-pop-mark)
     (global-set-key (kbd "s-J") 'avy-pop-mark)
     (global-set-key (kbd "A-h") 'avy-goto-char-timer)
     (global-set-key (kbd "A-j") 'avy-goto-char-timer)
     (global-set-key (kbd "A-H") 'avy-pop-mark)
     (global-set-key (kbd "A-J") 'avy-pop-mark)
   #+END_SRC

** Tramp
   #+BEGIN_SRC elisp
     (require 'tramp)
     (setq tramp-default-method "ssh")
     (setq tramp-verbose 9)

     ;; add tools
     (add-to-list 'tramp-remote-path "/nlu/tools/opt/bin")
   #+END_SRC

** Direx

   The [[https://github.com/m2ym/direx-el][direx]] package is a tree-based variation of dired, and it gives
   an /ide-like/ look and feel. Not sure of its useful-ness.

   #+BEGIN_SRC elisp
     ;; legacy - heavy todo
     ;; look at sidebar.el
     (require 'dired)

     (setq dired-listing-switches "-lah")
     (setq dired-hide-details-mode 1)

     (use-package dired-subtree
       :ensure t
       :init
       (define-key dired-mode-map (kbd "C-l") 'dired-subtree-toggle)
       (define-key dired-mode-map (kbd "C-j") 'dired-subtree-toggle))


     ;; (use-package direx
     ;;   :ensure t
     ;;   :bind (("C-c p X" . ha/projectile-direx)
     ;;          :map direx:direx-mode-map
     ;;          ("q" . kill-buffer-and-window)

     ;;          ("C-x C-j" . direx:jump-to-directory))
     ;;   :init
     ;;   (defun kill-buffer-and-window (&optional buffer)
     ;;     "Kills the buffer and closes the window it is in."
     ;;     (interactive)
     ;;     (kill-buffer buffer)
     ;;     (delete-window))

     ;;   (defun ha/projectile-direx (prefix)
     ;;     "Start direx in the top-level of a project in a buffer window
     ;;      that spans the entire left side of the frame."
     ;;     (interactive "P")
     ;;     (let ((file-name (file-name-nondirectory (buffer-file-name)))
     ;;           (buffer (direx:find-directory-reuse-noselect (projectile-project-root)))
     ;;           (window (ha/split-main-window 'left 30)))
     ;;       (select-window window)
     ;;       (direx:maybe-goto-current-buffer-item buffer)
     ;;       (switch-to-buffer buffer)
     ;;       (search-forward file-name))))
   #+END_SRC

   The following helper function creates a window at the top-level,
   ignoring other windows in the frame.

   #+BEGIN_SRC elisp
     (defun ha/split-main-window (direction size)
       "Split the main window in the DIRECTION where DIRECTION is a
     symbol with possible values of 'right, 'left, 'above or 'below
     and SIZE is the final size of the windows, if the window is split
     horizontally (i.e. DIRECTION 'below or 'above) SIZE is assumed to
     be the target height otherwise SIZE is assumed to be target width."
       (let* ((new-window (split-window (frame-root-window) nil direction))
              (horizontal (member direction '(right left))))
         (save-excursion
           (select-window new-window)
           (enlarge-window (- size (if horizontal
                                       (window-width)
                                     (window-height)))
                           horizontal))
         new-window))
   #+END_SRC

** SMEX

   Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]] to do something similar but with =M-x= commands:

   #+BEGIN_SRC elisp
     (use-package smex
       :ensure t
       :init (smex-initialize)
       :bind ("M-x" . smex)
             ("M-X" . smex-major-mode-commands))
   #+END_SRC

** Helm

   Helm

   #+BEGIN_SRC elisp
     (use-package helm
       :ensure t
       :init
       (use-package helm-config)
       (use-package helm-files))

     (define-key helm-command-map (kbd "o") 'helm-occur)
     (define-key helm-command-map (kbd "g") 'helm-do-grep)
     (define-key helm-command-map (kbd "SPC") 'helm-all-mark-rings)
     (define-key helm-map (kbd "M-k") 'helm-next-line)
     (define-key helm-map (kbd "M-i") 'helm-previous-line)
     (define-key helm-map (kbd "M-v") 'yank)
     (define-key helm-find-files-map (kbd "M-k") 'helm-next-line)
     (define-key helm-find-files-map (kbd "M-i") 'helm-previous-line)
     (define-key helm-find-files-map (kbd "M-v") 'yank)
     ;; rebind tab to run persistent action
     (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
     ;; make TAB works in terminal
     (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)

     (define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)

     (setq helm-split-window-in-side-p           t
           helm-buffers-fuzzy-matching           t
           helm-move-to-line-cycle-in-source     t
           helm-ff-search-library-in-sexp        t
           helm-ff-file-name-history-use-recentf t)

     (substitute-key-definition 'find-tag 'helm-etags-select global-map)
     (setq projectile-completion-system 'helm)
     (helm-mode 1)

     (setq helm-idle-delay 0.1)
     (setq helm-input-idle-delay 0.1)
     (define-key global-map (kbd "C-x b") 'helm-for-files)
     (define-key global-map (kbd "C-x C-f") 'helm-find-files)


     ;; Display helm buffers always at the bottom
     ;; Source: http://www.lunaryorn.com/2015/04/29/the-power-of-display-buffer-alist.html
     (add-to-list 'display-buffer-alist
                  `(,(rx bos "*helm" (* not-newline) "*" eos)
                    (display-buffer-reuse-window display-buffer-in-side-window)
                    (reusable-frames . visible)
                    (side            . bottom)
                    (window-height   . 0.4)))
   #+END_SRC

** Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
         (require 'init-client))
   #+END_SRC

** Org
   
   The main org-mode configuration is somewhere else:

   #+BEGIN_SRC elisp
     (if (window-system)
         (require 'init-org))
   #+END_SRC

** Smartparens

   Smartparens

   #+BEGIN_SRC elisp
     (use-package smartparens-config
       :ensure smartparens
       :config
       (progn
         (show-smartparens-global-mode t)))

     (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)

     (bind-keys
      :map smartparens-mode-map
      ("C-M-a" . sp-beginning-of-sexp)
      ("C-M-e" . sp-end-of-sexp)
 
      ("C-<down>" . sp-down-sexp)
      ("C-<up>"   . sp-up-sexp)
      ("M-<down>" . sp-backward-down-sexp)
      ("M-<up>"   . sp-backward-up-sexp)
 
      ("C-M-f" . sp-forward-sexp)
      ("C-M-b" . sp-backward-sexp)
 
      ("C-M-n" . sp-next-sexp)
      ("C-M-p" . sp-previous-sexp)
 
      ("C-S-f" . sp-forward-symbol)
      ("C-S-b" . sp-backward-symbol)
 
      ("C-<right>" . sp-forward-slurp-sexp)
      ("M-<right>" . sp-forward-barf-sexp)
      ("C-<left>"  . sp-backward-slurp-sexp)
      ("M-<left>"  . sp-backward-barf-sexp)
 
      ("C-M-t" . sp-transpose-sexp)
      ("C-M-k" . sp-kill-sexp)
      ("C-k"   . sp-kill-hybrid-sexp)
      ("M-k"   . sp-backward-kill-sexp)
      ("C-M-w" . sp-copy-sexp)
 
      ("C-M-d" . delete-sexp)
 
      ("M-<backspace>" . backward-kill-word)
      ("C-<backspace>" . sp-backward-kill-word)
      ([remap sp-backward-kill-word] . backward-kill-word)
 
      ("M-[" . sp-backward-unwrap-sexp)
      ("M-]" . sp-unwrap-sexp)
 
      ("C-x C-t" . sp-transpose-hybrid-sexp)
 
      ("C-c ("  . wrap-with-parens)
      ("C-c ["  . wrap-with-brackets)
      ("C-c {"  . wrap-with-braces)
      ("C-c \"" . wrap-with-double-quotes)
      ("C-c _"  . wrap-with-underscores)
      ("C-c `"  . wrap-with-back-quotes))
   #+END_SRC

** Whitespace Mode

   Just a test:

   #+BEGIN_SRC elisp
     (use-package whitespace
       :bind ("C-c T w" . whitespace-mode)
       :init
       (setq whitespace-line-column nil
             whitespace-display-mappings '((space-mark 32 [183] [46])
                                           (newline-mark 10 [9166 10])
                                           (tab-mark 9 [9654 9] [92 9])))
       :config
       (set-face-attribute 'whitespace-space nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-newline nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
       :diminish whitespace-mode)
   #+END_SRC

** Remote Shell Support
   #+BEGIN_SRC elisp
     (setq explicit-shell-file-name "/bin/sh")

     (defun apb/remote-shell (&optional host)
       "Open a remote shell to a host."
       (interactive)
       (with-temp-buffer
         (let ((host (if host host (read-string "Host: "))))
           (cd (concat "/pscp:" host ":"))
           (shell (concat "*" host "*")))))

     (defun apb/unv-shell ()
       (interactive)
       (apb/remote-shell "unv"))
   #+END_SRC
** Company

   #+BEGIN_SRC elisp
     (use-package company
       :ensure t
       :init
       (setq company-dabbrev-ignore-case t
             company-show-numbers t)
       (add-hook 'after-init-hook 'global-company-mode)
       :config
       (add-to-list 'company-backends 'company-math-symbols-unicode)
       :bind ("C-:" . company-complete)  ; In case I don't want to wait
       :diminish company-mode)

     (use-package company-quickhelp
       :ensure t
       :config
       (company-quickhelp-mode 1))
   #+END_SRC

** Selecting a Buffer

   #+BEGIN_SRC elisp
     (use-package kpm-list
       :ensure t
       :bind ("C-x C-b" . kpm-list))
   #+END_SRC

** Yasnippets
   
   #+BEGIN_SRC elisp
     (use-package yasnippet
       :ensure t
       :init
       (yas-global-mode 1)
       :config
       (add-to-list 'yas-snippet-dirs (apb/emacs-subdiretory "snippets")))
   #+END_SRC

** Magit

   #+BEGIN_SRC elisp
     (use-package magit
       :ensure t
       :commands magit-status magit-blame
       :config
       (setq magit-branch-arguments nil
             magit-completing-read-function 'magit-ido-completing-read
             magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
             magit-push-always-verify nil
             magit-restore-window-configuration t)
       :bind ("C-x g" . magit-status))
   #+END_SRC

** ConTeXt

   #+BEGIN_SRC elisp
     (use-package tex-mik
       :init
       (setq ConTeXt-Mark-version "IV")

       (add-hook 'ConTeXt-mode-hook
                 (lambda ()
                   (setq TeX-command-default "ConTeXt Full")))

       (add-to-list 'auto-mode-alist '("\\.mkiv\\'" . ConTeXt-mode))
       (add-to-list 'auto-mode-alist '("\\.mkvi\\'" . ConTeXt-mode))

       (with-eval-after-load "context"
         (add-to-list 'TeX-file-extensions "mkvi" t)
         (add-to-list 'TeX-file-extensions "mkiv" t)))
   #+END_SRC

** Global HS mode

   #+BEGIN_SRC elisp
     (define-globalized-minor-mode global-hs-minor-mode
       hs-minor-mode hs-minor-mode)

     (add-hook 'prog-mode-hook #'hs-minor-mode)
   #+END_SRC

* Modes for Work
** Unit Test Mode
   #+BEGIN_SRC elisp
     (require 'unit-test-mode)

     (add-to-list 'auto-mode-alist '("\.test" . unit-test-mode))
   #+END_SRC

** JSGF Mode
   #+BEGIN_SRC elisp
     (require 'jsgf-mode)

     (add-to-list 'auto-mode-alist '("\\.jsgf\\'" . jsgf-mode))
   #+END_SRC

** FAS Mode
   #+BEGIN_SRC elisp
     (use-package fas-mode
       :mode ("\.fieldannotatedstring" . fas-mode)
       :config
       (define-key fas-mode-map (kbd "C-c a") 'fas/prepare-string-by-fromer-line)
       (define-key fas-mode-map (kbd "C-c d") 'fas/replace-mention-by-sform))
   #+END_SRC
* Programming Mode Initialization

  #+BEGIN_SRC elisp
    ;; Elisp
    (require 'init-elisp)

    ;; Groovy
    ;; (require 'init-groovy)

    ;; Python
    (require 'init-python)

    ;; Stats
    (require 'init-stats)
  #+END_SRC

* Closing

  #+BEGIN_SRC elisp
    (provide 'init-main)
  #+END_SRC

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    header-args:elisp  :tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    header-args:shell  :tangle no
#+PROPERTY:    header-args        :results silent   :eval no-export   :comments org
